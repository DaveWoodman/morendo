options {
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  STATIC = false;
}

PARSER_BEGIN(CLIPSParser)

package org.jamocha.parser.clips;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.jamocha.rete.BoundParam;
import org.jamocha.rete.Constants;
import org.jamocha.rete.Deftemplate;
import org.jamocha.rete.Defcube;
import org.jamocha.rete.Defdimension;
import org.jamocha.rete.Defmeasure;
import org.jamocha.rete.Function;
import org.jamocha.rete.FunctionParam2;
import org.jamocha.rete.MultiSlot;
import org.jamocha.rete.Parameter;
import org.jamocha.rete.ParameterUtils;
import org.jamocha.rete.Rete;
import org.jamocha.rete.ShellBoundParam;
import org.jamocha.rete.Slot;
import org.jamocha.rete.ValueParam;
import org.jamocha.rete.functions.ShellFunction;
import org.jamocha.rule.Action;
import org.jamocha.rule.AndCondition;
import org.jamocha.rule.AndLiteralConstraint;
import org.jamocha.rule.BoundConstraint;
import org.jamocha.rule.Condition;
import org.jamocha.rule.Constraint;
import org.jamocha.rule.Defrule;
import org.jamocha.rule.Defquery;
import org.jamocha.rule.GraphQuery;
import org.jamocha.rule.ExistCondition;
import org.jamocha.rule.FunctionAction;
import org.jamocha.rule.LiteralConstraint;
import org.jamocha.rule.MultiValue;
import org.jamocha.rule.MultipleCondition;
import org.jamocha.rule.ObjectCondition;
import org.jamocha.rule.OnlyCondition;
import org.jamocha.rule.OrLiteralConstraint;
import org.jamocha.rule.PredicateConstraint;
import org.jamocha.rule.RuleProperty;
import org.jamocha.rule.CubeQueryCondition;
import org.jamocha.rule.TestCondition;
import org.jamocha.rule.TemporalCondition;
import org.jamocha.rete.functions.DeffunctionFunction;

public class CLIPSParser {

    protected Rete engine = null;

    public CLIPSParser(Rete eng, Reader stream) {
        this(stream);
        engine = eng;
    }

    public CLIPSParser(Rete eng, InputStream stream) {
        this(new InputStreamReader(stream));
        engine = eng;
    }

    public void close() {
        engine = null;
        if (token != null) {
            token.next = null;
	    	token.specialToken = null;
            token = null;
        }
        if (jj_nt != null) {
            jj_nt.next = null;
	    	jj_nt.specialToken = null;
            jj_nt = null;
        }
        if (jj_scanpos != null) {
         	jj_scanpos.next = null;
	    	jj_scanpos.specialToken = null;   
            jj_scanpos = null;
        }
        if (jj_lastpos != null) {
            jj_lastpos.next = null;
	    	jj_lastpos.specialToken = null;
            jj_lastpos = null;
        }
        try {
            jj_input_stream.inputStream.close();
        } catch (IOException e) {
            // later on log the error
        }
    }
}

PARSER_END(CLIPSParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

/* COMMENTS */

SPECIAL_TOKEN : {
< COMMENT: ";;"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >
| < INTEGER_LITERAL: ("-")? ["0"-"9"] (["0"-"9"])* >
|
  < FLOATING_POINT_LITERAL:
        (("-")? ["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      |("-")? "." (["0"-"9"])+ (<EXPONENT>)?
      | (("-")? ["0"-"9"])+ <EXPONENT>
  >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
| < BIND: ("?"(<LETTER>|<DIGIT>)+) >
| < BIND2: ("?"(<LETTER>|<DIGIT>)+"&:") >
| < BIND3: ("?*"(<LETTER>|<DIGIT>)+"*") >
| < BIND4: ("$?"(<LETTER>|<DIGIT>)+) >
| < BIND5: ("?"(<LETTER>|<DIGIT>)+"&~") >
| < BINDING: "bind" >
| < BOOLEAN: "BOOLEAN" >
| < AGGREGATE: "aggregate" >
| < ASSERT: "assert" >
| < ASSERTTEMPORAL: "assert-temporal" >
| < AUTOFOCUS: "auto-focus" >
| < ALLOWEDVALUES: "allowed-values" >
| < CHAININGDIRECTION: "chaining-direction" >
| < COMMAND: "command" >
| < CUBEQUERY: "cubequery" >
| < DECLARE: "declare" >
| < DEFCLASS: "defclass" >
| < DEFCUBE: "defcube" >
| < DEFFACT: "deffact" >
| < DEFFUNCTION: "deffunction" >
| < DEFMODULE: "defmodule" >
| < DEFRULE: "defrule" >
| < DEFQUERY: "defquery" >
| < DEFGRAPHQUERY: "defgraphquery" >
| < DEFTEMPLATE: "deftemplate" >
| < DESCRIBECLASS: "describe-class" >
| < DEFAULTVALUE: "default" >
| < DOUBLE: "DOUBLE" >
| < EXISTS: "exists" >
| < EFFECTIVE: "effective-date" >
| < EXPIRATION: "expiration-date" >
| < FACTINDEX: "fact-index" >
| < FLOAT: "FLOAT" >
| < HASHEDMEMORY: "hashed-memory" >
| < INTEGER: "INTEGER" >
| < INTERVALTIME: "interval-time" >
| < LOGICAL: "logical" >
| < LONG: "LONG" >
| < MODIFY: "modify" >
| < MULTISLOT: "multislot" >
| < MULTIPLECE: "multiple" >
| < NOAGENDA: "no-agenda" >
| < NOLOOP: "no-loop" >
| < NUMBER: "NUMBER" >
| < NOTCE: "not" >
| < ONLYCE: "only" >
| < REMEMBERALPHA: "remember-alpha" >
| < RETRACT: "retract" >
| < RULEVERSION: "rule-version" >
| < RELATIVETIME: "relative-time" >
| < SALIENCE: "salience" >
| < SEND: "send" >
| < SHORT: "SHORT" >
| < SLOT: "slot" >
| < STRING: "STRING" >
| < SYMBOL: "symbol" >
| < TEMPORALACTIVATION: "temporal-activation" >
| < TEMPORAL: "temporal" >
| < TEST: "test" >
| < TRUE: "TRUE" >
| < TRUE2: "true" >
| < TYPEDEF: "type" >
| < FALSE: "FALSE" >
| < FALSE2: "false" >
| < NIL: "nil" >
| < ARROW: "=>" >
| < LEFT_ARROW: "<<=" >
| < ASSIGN: "<-" >
| < SEMICOLON: ";" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULTIPLY: "*" >
| < DIVIDE: "/" >
| < GT1: ">" >
| < LT1: "<" >
| < EQ1: "==" >
| < EQ2: "eq" >
| < LE1: "<=" >
| < GE1: ">=" >
| < NE1: "<>" >
| < NE2: "!=" >
| < AND1: "and" >
| < AND2: "&" >
| < OR1: "or" >
| < OR2: "|" >
| < TILDA: "~" >
| < IDENTIFIER: (<LETTER>|<DIGIT>|<TYPEDEF>|<TILDA>|["_",":","-","$",".","@","/"])+ >
|
  < LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
|
  < PATH_LITERAL:
      (<LETTER>|<DIGIT>|["_",":","-","\\","/","."])+
  >
}

Object basicExpr() :
 {
  Object exp = null;
  Token obj = null;
  ShellFunction func = null;
  Parameter[] pms = null;
  ShellBoundParam sbp = null;
  // ArrayList<Object> list = new ArrayList<Object>();
}
{
  obj = getBindType()
  {
    func = new ShellFunction();
    func.setName("echo");
    sbp = new ShellBoundParam();
    sbp.setDefglobalName(obj.image);
    pms = new ShellBoundParam[]{sbp};
    func.setParameters(pms);
    return func;
  }
|
  (<LBRACE> exp = expr() <RBRACE>)
  {
    return exp;
  }
|
	(obj = <IDENTIFIER>)
	{
	  return obj.image;
	}
|
  (obj = <STRING_LITERAL>)
  {
    return ParserUtils.getStringLiteral(obj.image);
  }
|
  <EOF>
  {
    return null;
  }
}

// main expression for loading a data file
List<Object> loadExpr() :
{
  ArrayList<Object> facts = new ArrayList<Object>();
}
{
  (loadAllExpr(facts))+
  {
    return facts;
  }
}

// this method is used to load data
void loadAllExpr(List<Object> list) :
{
  ValueParam[] param = null;
}
{
  param = assertBody()
  {
    list.add(param);
  }
}

Object streamExpr() :
{
  ValueParam[] param = null;
}
{
  param = assertBody()
  {
    return param;
  }
|
  <EOF>
  {
    return null;
  }
}

// typeExpr is only responsible for parsing string and bigdecimal types
Object typeExpr() :
{
  Token exp;
}
{
  exp = <INTEGER_LITERAL>
  {
    // we use BigDecimal
    return new BigDecimal(exp.image);
  }  
|
  exp = <STRING_LITERAL>
  {
    String strlit = exp.image;
    strlit = ParserUtils.getStringLiteral(strlit);
    return strlit;
  }
|
  exp = <FLOATING_POINT_LITERAL>
  {
    // we use float, double
    return new BigDecimal(exp.image);
  }
|
  exp = <PATH_LITERAL>
  {
    return exp.image;
  }
}

Object expr() :
{
  Token exp = null;
  Token exp2 = null;
  // Token exp3 = null;
  String body;
  // ValueParam param;
  // Deffact fact;
  Deftemplate templ;
  Defrule rule;
  Defquery query;
  GraphQuery graphquery;
  Defcube cube;
  ShellFunction func;
  DeffunctionFunction dffunc;
  ArrayList<Object> list = new ArrayList<Object>();
  ValueParam[] pms;
  List<Object> infunc = new ArrayList<Object>();
}
{
  exp = <ASSERT> <LBRACE> exp2 = <IDENTIFIER>
  (assertContents(list))+ <RBRACE>
  {
    func = new ShellFunction();
    func.setName(exp.image);
    pms = new ValueParam[2];
    pms[0] = new ValueParam(Constants.STRING_TYPE,exp2.image);
    pms[1] = new ValueParam(Constants.OBJECT_TYPE,list.toArray());
    func.setParameters(pms);
    exp.next = null;
	exp.specialToken = null;
    exp = null;
    return func;
  }
|
  exp = <ASSERTTEMPORAL> <LBRACE> exp2 = <IDENTIFIER>
  (assertContents(list))+ <RBRACE>
  {
    func = new ShellFunction();
    func.setName(exp.image);
    pms = new ValueParam[2];
    pms[0] = new ValueParam(Constants.STRING_TYPE,exp2.image);
    pms[1] = new ValueParam(Constants.OBJECT_TYPE,list.toArray());
    func.setParameters(pms);
    exp.next = null;
	exp.specialToken = null;
    exp = null;
    return func;
  }
|
  exp = <RETRACT> (exp2 = <BIND> | exp2 = <INTEGER_LITERAL>)
  {
    func = new ShellFunction();
    func.setName(exp.image);
    Parameter[] rpms = new Parameter[1];
    if (exp2.image.startsWith("?")) {
      BoundParam bp = new BoundParam();
      bp.setVariableName(exp2.image);
      rpms[0] = bp;
    } else {
      ValueParam vp = new ValueParam(Constants.BIG_DECIMAL, new BigDecimal(exp2.image));
      rpms[0] = vp;
    }
    func.setParameters(rpms);
    exp.next = null;
	exp.specialToken = null;
    exp = null;
    exp2.next = null;
	exp2.specialToken = null;
    exp2 = null;
    return func;
  }
|
  exp = <MODIFY> exp2 = <BIND> (assertContents(list))+
  {
    func = new ShellFunction();
    func.setName(exp.image);
    BoundParam bp = new BoundParam();
    bp.setVariableName(exp2.image);
    list.add(0,bp);
    func.setParameters(ParameterUtils.slotToParameters(list));
    exp.next = null;
	exp.specialToken = null;
    exp = null;
    return func;
  }
|
  exp = <DEFTEMPLATE>
  templ = templateExpr()
  {
    func = new ShellFunction();
    func.setName(exp.image);
    pms = new ValueParam[1];
    pms[0] = new ValueParam(Constants.OBJECT_TYPE,templ);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFCUBE>
  cube = cubeExpr()
  {
    func = new ShellFunction();
    func.setName(exp.image);
    pms = new ValueParam[1];
    pms[0] = new ValueParam(Constants.OBJECT_TYPE,cube);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFMODULE>
  body = getIdentifier()
  {
    func = new ShellFunction();
    func.setName(exp.image);
    pms = new ValueParam[1];
    pms[0] = new ValueParam(Constants.STRING_TYPE,body);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFRULE>
  rule = ruleBody() 
  {
    func = new ShellFunction();
    func.setName(exp.image);
    pms = new ValueParam[1];
    pms[0] = new ValueParam(Constants.OBJECT_TYPE,rule);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFQUERY>
  query = queryBody()
  {
    func = new ShellFunction();
    func.setName(exp.image);
    pms = new ValueParam[1];
    pms[0] = new ValueParam(Constants.OBJECT_TYPE,query);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFGRAPHQUERY>
  graphquery = graphQueryBody()
  {
    func = new ShellFunction();
    func.setName(exp.image);
    pms = new ValueParam[1];
    pms[0] = new ValueParam(Constants.OBJECT_TYPE,graphquery);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFCLASS> ((valueParams(list))+)?
  {
    func = new ShellFunction();
    func.setName(exp.image);
    func.setParameters(ParameterUtils.convertParameters(list));
    list.clear();
    return func;
  }
|
  exp = <DEFFUNCTION>
  exp2 = <IDENTIFIER> <LBRACE>
  ((bindingParams(list))+)? <RBRACE> <LBRACE>
  (ruleAction(infunc))? <RBRACE>
  {
    dffunc = new DeffunctionFunction();
    dffunc.setName(exp2.image);
    dffunc.setParameters(ParameterUtils.convertParameters(list));
    dffunc.setFunction(infunc);
    list.clear();
    return dffunc;
  }
|
  // example: (bind ?*x* 9)
  <BINDING> exp = getBindType() (valueParams(list))+
  {
    func = new ShellFunction();
    func.setName("bind");
    list.add(0,new ValueParam(Constants.STRING_TYPE,exp.image.substring(1)));
    func.setParameters(ParameterUtils.convertParameters(list));
    list.clear();
    return func;
  }
|
  (exp = <PLUS>|
   exp = <MINUS>|
   exp = <MULTIPLY>|
   exp = <DIVIDE>|
   exp = <GT1>|
   exp = <LT1>|
   exp = <EQ1>|
   exp = <EQ2>|
   exp = <LE1>|
   exp = <GE1>|
   exp = <NE1>|
   exp = <OR1> |
   exp = <AND1> |
   exp = <NOTCE> )(valueParams(list))+
  {
    func = new ShellFunction();
    func.setName(exp.image);
    func.setParameters(ParameterUtils.convertParameters(list));
    list.clear();
    return func;
  }
|
  exp = <IDENTIFIER> ((valueParams(list))+)?
  {
    func = new ShellFunction();
    func.setName(exp.image);
    func.setParameters(ParameterUtils.convertParameters(list));
    list.clear();
    return func;
  }
}

void valueParams(List<Object> list) :
{
  Object exp;
  Token tok;
  ValueParam vp = null;
}
{
  LOOKAHEAD(<LBRACE>)<LBRACE>exp = expr()<RBRACE>
  {
    ShellFunction subfunc = (ShellFunction)exp;
    FunctionParam2 fp2 = new FunctionParam2();
    fp2.setFunctionName(subfunc.getName());
    fp2.setEngine(engine);
    fp2.setParameters(subfunc.getParameters());
    list.add(fp2);
  }
|
  exp = typeExpr()
  {
    vp = new ValueParam();
      vp.setValue(exp);
    if (exp instanceof BigDecimal) {
      vp.setValueType(Constants.BIG_DECIMAL);
    } else if (exp instanceof String) {
      vp.setValueType(Constants.STRING_TYPE);
    }
    list.add(vp);
  }
|
  exp = <IDENTIFIER>
  {
    vp = new ValueParam();
    vp.setValueType(Constants.STRING_TYPE);
    if (exp instanceof Token) {
      vp.setValue( ((Token)exp).image );
    } else {
      vp.setValue(exp);
    }
    list.add(vp);
  }
|
  exp = <TRUE>
  {
    vp = new ValueParam();
    vp.setValue(Boolean.TRUE);
    list.add(vp);
  }
|
  exp = <TRUE2>
  {
    vp = new ValueParam();
    vp.setValue(Boolean.TRUE);
    list.add(vp);
  }
|
  exp = <FALSE>
  {
    vp = new ValueParam();
    vp.setValue(Boolean.FALSE);
    list.add(vp);
  }
|
  exp = <FALSE2>
  {
    vp = new ValueParam();
    vp.setValue(Boolean.FALSE);
    list.add(vp);
  }
|
  // in some cases, the parameters may be a binding to a variable
  tok = getBindType()
  {
    BoundParam bp = new BoundParam();
    if (tok.kind == CLIPSParserConstants.BIND4) {
      bp.setVariableName(tok.image.substring(2));
      bp.setIsMultislot(true);
    } else {
      bp.setVariableName(tok.image);
    }
    list.add(bp);
  }
}

/**
 * bindingParams is meant to parse the params for a deffunction
 */
void bindingParams(List<Object> list) :
{
  Object exp;
  Token tok;
  // ValueParam vp = null;
}
{
  tok = getBindType()
  {
    BoundParam bp = new BoundParam();
    if (tok.kind == CLIPSParserConstants.BIND4) {
      bp.setVariableName(tok.image.substring(2));
      bp.setIsMultislot(true);
    } else {
      bp.setVariableName(tok.image);
    }
    list.add(bp);
  }
}

Token getBindType() :
{
  Token exp;
}
{
  exp = <BIND3>
  {
    return exp;
  }
|
  exp = <BIND>
  {
    return exp;
  }
|
  exp = <BIND4>
  {
    return exp;
  }
}

/**
 * this is for convenience
 */
String getIdentifier() :
{
  Token exp;
}
{
  exp = <IDENTIFIER>
  {
    return exp.image;
  }
}

ValueParam[] assertBody() :
{
  Token exp;
  List<Object> tokens = new ArrayList<Object>();
  ValueParam[] param = null;
}
{
  <LBRACE> exp = <IDENTIFIER> (assertContents(tokens))+ <RBRACE>
  {
    param = new ValueParam[2];
    param[0] = new ValueParam(Constants.STRING_TYPE,exp.image);
    param[1] = new ValueParam(Constants.OBJECT_TYPE,tokens.toArray());
    tokens.clear();
    exp = null;
    return param;
  }
}

/* assert body */
void assertContents(List<Object> tokens) :
{
  Token exp;
  Object body = null;
}
{
  <LBRACE> exp = <IDENTIFIER> (body = checkMultiSlot())? <RBRACE>
  {
    if (body != null) {
      if (body instanceof Object[]) {
        MultiSlot msl = new MultiSlot(exp.image);
        msl.setValue(body);
        tokens.add(msl);
      } else {
        Slot s = new Slot(exp.image);
        s.setValue(body);
        tokens.add(s);
      }
    }
    exp.next = null;
	exp.specialToken = null;
    exp = null;
    body = null;
  }
}

Object checkMultiSlot() :
{
  Object body;
  ArrayList<Object> artokens = new ArrayList<Object>();
}
{
  LOOKAHEAD(<IDENTIFIER><IDENTIFIER>) (arrayType(artokens))+
  {
    return artokens.toArray();
  }
|
  LOOKAHEAD(<STRING_LITERAL><STRING_LITERAL>) (arrayType(artokens))+
  {
    return artokens.toArray();
  }
|
  LOOKAHEAD(<INTEGER_LITERAL><INTEGER_LITERAL>) (arrayType(artokens))+
  {
    return artokens.toArray();
  }
|
  LOOKAHEAD(<FLOATING_POINT_LITERAL><FLOATING_POINT_LITERAL>) (arrayType(artokens))+
  {
    return artokens.toArray();
  }
|
  LOOKAHEAD(<BIND><BIND>) (arrayType(artokens))+
  {
    return artokens.toArray();
  }
|
  LOOKAHEAD(<BIND3><BIND3>) (arrayType(artokens))+
  {
    return artokens.toArray();
  }
|
  body = slotValueType()
  {
    return body;
  }
}

Object slotValueType() :
{
  Object body;
  Token btoken;
  boolean boolval;
}
{
  btoken = getBindType()
  {
    // probably should refactor this later, instead of looking up the value directly
    Object val = engine.getDefglobalValue(btoken.image);
    if (val != null) {
      return engine.getDefglobalValue(btoken.image);
    } else {
      BoundParam bp = new BoundParam();
      bp.setVariableName(btoken.image);
      return bp;
    }
  }
|
  body = typeExpr()
  {
    return body;
  }
|
  boolval = trueFalse()
  {
    return boolval;
  }
|
  btoken = <IDENTIFIER>
  {
    return btoken.image;
  }
}

/* arrayType handles multislot tokens */
void arrayType(List<Object> tokens) :
{
  Token tval;
  Object val;
}
{
  tval = <IDENTIFIER>
  {
    tokens.add(tval.image);
  }
|
  tval = <BIND>
  {
    if (tval.kind == CLIPSParserConstants.BIND) {
      BoundParam bp = new BoundParam();
      bp.setVariableName(tval.image);
      tokens.add(bp);
    }
  }
|
  tval = <BIND3>
  {
    if (tval.kind == CLIPSParserConstants.BIND3) {
      BoundParam bp = new BoundParam();
      bp.setVariableName(tval.image);
      tokens.add(bp);
    }
  }
|
  val = typeExpr()
  {
    tokens.add(val);
  }
}

/* templateExpr gets the slots of a deftemplate */
Deftemplate templateExpr() :
{
  Token exp;
  Deftemplate tmplate;
  List<Object> slots = new ArrayList<Object>();
}
{
  /* javacc gives a warning for this, but not sure how to do it better */
  exp = <IDENTIFIER> (templateBody(slots))+
  {
    Slot[] s = new Slot[slots.size()];
    slots.toArray(s);
    tmplate = new Deftemplate(exp.image,null,s);
    slots.clear();
    exp.next = null;
	exp.specialToken = null;
    exp = null;
    return tmplate;
  }
}

void templateBody(List<Object> slots) :
{
  Token sname;
  int stype;
  int sid;
  Slot sl;
  MultiSlot msl;
  Object defaultvalue;
}
{
  LOOKAHEAD(<LBRACE> <SLOT>)<LBRACE> <SLOT> sname = <IDENTIFIER> 
  stype = slotType() defaultvalue = defaultValue() <RBRACE>
  {
    sid = slots.size();
    sl = new Slot(sname.image);
    sl.setId(sid);
    sl.setValueType(stype);
    sl.setDefaultValue(defaultvalue);
    slots.add(sl);
    sname = null;
  }
|
  LOOKAHEAD(<LBRACE> <MULTISLOT>)<LBRACE> <MULTISLOT> sname = <IDENTIFIER> <RBRACE>
  {
    sid = slots.size();
    msl = new MultiSlot(sname.image);
    msl.setId(sid);
    slots.add(msl);
    sname = null;
  }
}

int slotType() :
{
  int stype = -1;
  int defaultType = 9;
}
{
  /* the type declaration is optional, so question mark is used to tell javacc */
  (LOOKAHEAD(<LBRACE> <TYPEDEF>) <LBRACE> <TYPEDEF> stype = getType() <RBRACE>)?
  {
    if (stype > -1) {
      defaultType = stype;
    }
    return defaultType;
  }
}

Object defaultValue() :
{
  Object defobj = null;
}
{
  /* default value is optional */
  (LOOKAHEAD(<LBRACE> <DEFAULTVALUE>) <LBRACE> <DEFAULTVALUE> defobj = typeExpr() <RBRACE>)?
  {
    return defobj;
  }
}

int getType() :
{
  Token exp = null;
}
{
  exp = <INTEGER>
  {
    exp = null;
    return Constants.INT_PRIM_TYPE;
  }
|
  exp = <SHORT>
  {
    exp = null;
    return Constants.SHORT_PRIM_TYPE;
  }
|
  exp = <LONG>
  {
    exp = null;
    return Constants.LONG_PRIM_TYPE;
  }
|
  exp = <FLOAT>
  {
    exp = null;
    return Constants.FLOAT_PRIM_TYPE;
  }
|
  exp = <DOUBLE>
  {
    exp = null;
    return Constants.DOUBLE_PRIM_TYPE;
  }
|
  exp = <SYMBOL>
  {
    exp = null;
    return Constants.OBJECT_TYPE;
  }
|
  exp = <STRING>
  {
    exp = null;
    return Constants.STRING_TYPE;
  }
|
  exp = <BOOLEAN>
  {
    exp = null;
    return Constants.BOOLEAN_PRIM_TYPE;
  }
|
  exp = <IDENTIFIER>
  {
    if (exp.image.equals("DATE")) {
      return Constants.DATE_TYPE;
    } else {
      return Constants.OBJECT_TYPE;
    }
  }
}

Defrule ruleBody() :
{
  Token exp = null;
  Token rulecomment = null;
  Defrule rule;
  List<Object> dec = new ArrayList<Object>();
  List<Object> conditions = new ArrayList<Object>();
  List<Object> actions = new ArrayList<Object>();
  List<Object> modactions = new ArrayList<Object>();
}
{
  exp = <IDENTIFIER> (LOOKAHEAD(<STRING_LITERAL>)rulecomment=<STRING_LITERAL>)?
  (LOOKAHEAD(<LBRACE><DECLARE>)ruleDeclaration(dec))? ((conditionElement(conditions))+)?
  arrow() 
  ruleActions(actions)
  ( leftarrow()  ruleActions(modactions) )?
  {
    rule = new Defrule(exp.image);
    if (rulecomment != null) {
      rule.setComment(rulecomment.image);
    }
    rule.setRuleProperties(dec);
    Iterator<Object> itr = conditions.iterator();
    while (itr.hasNext()) {
      rule.addCondition( (Condition)itr.next() );
    }
    
    itr = actions.iterator();
    while (itr.hasNext()) {
      Object acn = itr.next();
      if (acn instanceof Function) {
        FunctionAction faction = new FunctionAction();
        faction.setFunction((Function)acn);
        rule.addAction(faction);
      } else if (acn instanceof Action) {
        rule.addAction( (Action)acn );
      }
    }
    itr = modactions.iterator();
    while (itr.hasNext()) {
      Object acn = itr.next();
      if (acn instanceof Function) {
        FunctionAction faction = new FunctionAction();
        faction.setFunction((Function)acn);
        rule.addModificationAction(faction);
      } else if (acn instanceof Action) {
        rule.addModificationAction( (Action)acn );
      }
    }
    dec.clear();
    conditions.clear();
    actions.clear();
    modactions.clear();
    exp = null;
    return rule;
  }
}

void ruleDeclaration(List<Object> list) :
{
  Token exp;
}
{
  <LBRACE> exp = <DECLARE> (ruleProperty(list)) <RBRACE>
  {
  }
}

void ruleProperty(List<Object> list) :
{
  Object exp = null;
  boolean tf = true;
  String ver = null;
  boolean remember = true;
  boolean temporal = false;
  boolean agenda = false;
  String direction = null;
  String date = null;
  RuleProperty rmem;
}
{
  (LOOKAHEAD(<LBRACE><SALIENCE>)exp = salience())?
  {
    if (exp != null) {
      Long intsal = Long.valueOf(((Token)exp).image);
      RuleProperty sal = new RuleProperty(RuleProperty.SALIENCE,intsal.intValue());
      list.add(sal);
    }
  }
  (LOOKAHEAD(<LBRACE><AUTOFOCUS>)tf = autoFocus())?
  {
    RuleProperty auto = new RuleProperty(RuleProperty.AUTO_FOCUS,tf);
    list.add(auto);
  }
  (LOOKAHEAD(<LBRACE><RULEVERSION>) ver = ruleVersion())?
  {
    RuleProperty rp = new RuleProperty(RuleProperty.VERSION,ver);
    list.add(rp);
  }
  (LOOKAHEAD(<LBRACE><REMEMBERALPHA>) remember = remember())?
  {
    rmem = new RuleProperty(RuleProperty.REMEMBER_ALPHA,remember);
    list.add(rmem);
  }
  (LOOKAHEAD(<LBRACE><HASHEDMEMORY>) remember = remember())?
  {
    rmem = new RuleProperty(RuleProperty.HASHED_MEMORY,remember);
    list.add(rmem);
  }
  (LOOKAHEAD(<LBRACE><EFFECTIVE>) date = effectiveDate())?
  {
    RuleProperty eff = new RuleProperty(RuleProperty.EFFECTIVE_DATE,date);
    list.add(eff);
  }
  (LOOKAHEAD(<LBRACE><EXPIRATION>) date = expirationDate())?
  {
    RuleProperty expr = new RuleProperty(RuleProperty.EXPIRATION_DATE,date);
    list.add(expr);
  }
  (LOOKAHEAD(<LBRACE><CHAININGDIRECTION>) direction = direction())?
  {
    RuleProperty dir = new RuleProperty(RuleProperty.DIRECTION,direction);
    list.add(dir);
  }
  (LOOKAHEAD(<LBRACE><NOAGENDA>) agenda = noAgenda())?
  {
    RuleProperty noagenda = new RuleProperty(RuleProperty.NO_AGENDA,agenda);
    list.add(noagenda);
  }
  (LOOKAHEAD(<LBRACE><TEMPORALACTIVATION>) temporal = temporalAct())?
  {
    RuleProperty tempprop = new RuleProperty(RuleProperty.TEMPORAL_ACTIVATION,temporal);
    list.add(tempprop);
  }
}

Object salience() :
{
  Token exp = null;
  Object val = null;
}
{
  <LBRACE> exp = <SALIENCE> val = <INTEGER_LITERAL> <RBRACE>
  {
    exp = null;
    if (val != null) {
      return val;
    } else {
      return null;
    }
  }
}

boolean autoFocus() :
{
  Token exp;
  boolean tf = false;
}
{
  <LBRACE> exp = <AUTOFOCUS> tf = trueFalse() <RBRACE>
  {
    return tf;
  }
}

String ruleVersion() :
{
  Token exp;
}
{
  <LBRACE><RULEVERSION> (exp = <IDENTIFIER>| exp = <FLOATING_POINT_LITERAL> | exp = <INTEGER_LITERAL> )
   <RBRACE>
  {
    return exp.image;
  }
}

boolean remember() :
{
  Token exp;
  boolean tf = false;
}
{
  <LBRACE> exp = <REMEMBERALPHA> tf = trueFalse() <RBRACE>
  {
    return tf;
  }
}

String direction() :
{
  Token exp;
  String defaultDir = "forward";
}
{
  <LBRACE><CHAININGDIRECTION> exp = <IDENTIFIER> <RBRACE>
  {
    if (exp != null && exp.image.equals("backward")) {
      return exp.image;
    } else {
      return defaultDir;
    }
  }
}

boolean noAgenda() :
{
  Token exp;
  boolean tf = false;
}
{
  <LBRACE> exp = <NOAGENDA> tf = trueFalse() <RBRACE>
  {
    return tf;
  }
}

String effectiveDate() :
{
  Token exp;
  Token date;
}
{
  <LBRACE> exp = <EFFECTIVE> date = <STRING_LITERAL> <RBRACE>
  {
    return date.image.substring(1,date.image.length() - 1);
  }
}

String expirationDate() :
{
  Token exp;
  Token date;
}
{
  <LBRACE> exp = <EXPIRATION> date = <STRING_LITERAL> <RBRACE>
  {
    return date.image.substring(1,date.image.length() - 1);
  }
}

boolean temporalAct() :
{
  Token exp;
  boolean tf = false;
}
{
  <LBRACE> exp = <TEMPORALACTIVATION> tf = trueFalse() <RBRACE>
  {
    return tf;
  }
}

Boolean trueFalse() :
{
}
{
  <TRUE>
  {
    return Boolean.TRUE;
  }
|
  <TRUE2>
  {
    return Boolean.TRUE;
  }
|
  <FALSE>
  {
    return Boolean.FALSE;
  }
|
  <FALSE2>
  {
    return Boolean.FALSE;
  }
}

// conditionalElement checks for object binding
void conditionElement(List<Object> list) :
{
  Token exp;
}
{
  // handle ?var <- (context (name startup) )
  LOOKAHEAD(<BIND>) exp = <BIND> <ASSIGN> <LBRACE> CEType(list) <RBRACE>
  {
    ObjectCondition oc = (ObjectCondition)list.get(list.size() -1);
    BoundConstraint bc = new BoundConstraint(oc.getTemplateName(),true);
    bc.setValue(exp.image.substring(1));
    oc.addConstraint(bc,0);
  }
|
  // parse the conditional elements without binding
  <LBRACE> CEType(list) <RBRACE>
  {
  }
}

// CEType checks the Conditional element to see if it's exist, not, test or plain
void CEType(List<Object> list) :
{
  Token exp;
  // Token exp2;
  // Object etime;
  Object nested = null;
  List<Object> alpha = new ArrayList<Object>();
  ObjectCondition oc = null;
  CubeQueryCondition cubec = null;
  // TemporalCondition tmpc = null;
  // List<Object> params = new ArrayList<Object>();
  AndCondition andcond = new AndCondition();
}
{
  // (not (path (id ?seatID) (name ?g2) ) )
  LOOKAHEAD(<NOTCE><LBRACE><IDENTIFIER><LBRACE>)
  <NOTCE> <LBRACE> exp = <IDENTIFIER> ((templatePatterns(alpha))+)? <RBRACE>
  {
    oc = new ObjectCondition();
    oc.setNegated(true);
    oc.setTemplateName(exp.image);
    Iterator<Object> itr = alpha.iterator();
    while (itr.hasNext()) {
      oc.addConstraint((Constraint)itr.next());
    }
    list.add(oc);
    alpha.clear();
    exp = null;
  }
|
  // (not (test (> 3 2) ) )
  <NOTCE> <LBRACE> nested = expr() <RBRACE>
  {
    TestCondition tc = new TestCondition();
    tc.setNegated(true);
    if (nested instanceof Function) {
      tc.setFunction((Function)nested);
    }
    list.add(tc);
  }
|
  <CUBEQUERY> <LBRACE> exp = <IDENTIFIER> ((templatePatterns(alpha))+)? <RBRACE>
  {
    cubec = new CubeQueryCondition();
    cubec.setTemplateName(exp.image);
    Iterator<Object> itr2 = alpha.iterator();
    while (itr2.hasNext()) {
      cubec.addConstraint((Constraint)itr2.next());
    }
    list.add(cubec);
    alpha.clear();
    exp = null;
  }
|
  // (temporal ?binding (relative-time n) (person (name "me") ) )
  <TEMPORAL> temporalPattern(list)
  {
  }
|
  // (test (> ?var1 ?var2) )
  <TEST> <LBRACE> nested = expr() <RBRACE>
  {
    TestCondition tc = new TestCondition();
    if (nested instanceof Function) {
      tc.setFunction((Function)nested);
    }
    list.add(tc);
  }
|
  <AND1> (<LBRACE> nestedCE(andcond) <RBRACE>)+
  {
    list.add(andcond);
  }
|
  // existential CE is from first order logic
  <EXISTS> (<LBRACE> CEType(alpha) <RBRACE>)+
  {
    ExistCondition exc = null;
    if (alpha.size() > 1) {
      for (int iz=0; iz < alpha.size(); iz++) {
        exc = ExistCondition.newExistCondition((ObjectCondition)alpha.get(iz));
        list.add(exc);
      }
    } else {
      exc = ExistCondition.newExistCondition((ObjectCondition)alpha.get(0));
      list.add(exc);
    }
  }
|
  // only CE is from second order logic
  <ONLYCE> (<LBRACE> CEType(alpha) <RBRACE>)+
  {
    OnlyCondition only = null;
    if (alpha.size() > 1) {
      for (int iz=0; iz < alpha.size(); iz++) {
        only = OnlyCondition.newOnlyCondition((ObjectCondition)alpha.get(iz));
        list.add(only);
      }
    } else {
      only = OnlyCondition.newOnlyCondition((ObjectCondition)alpha.get(0));
      list.add(only);
    }
  }
|
  // multiple CE is from second order logic
  <MULTIPLECE> (<LBRACE> CEType(alpha) <RBRACE>)+
  {
    MultipleCondition multiple = null;
    if (alpha.size() > 1) {
      for (int iz=0; iz < alpha.size(); iz++) {
        multiple = MultipleCondition.newMultipleCondition((ObjectCondition)alpha.get(iz));
        list.add(multiple);
      }
    } else {
      multiple = MultipleCondition.newMultipleCondition((ObjectCondition)alpha.get(0));
      list.add(multiple);
    }
  }
|
  // regular conditional element (myobject (name "first")(age 40) )
  exp = <IDENTIFIER> ((templatePatterns(alpha))+)?
  {
    oc = new ObjectCondition();
    oc.setTemplateName(exp.image);
    Iterator<Object> itr = alpha.iterator();
    while (itr.hasNext()) {
      oc.addConstraint((Constraint)itr.next());
    }
    list.add(oc);
    alpha.clear();
    exp = null;
  }
}

void nestedCE(AndCondition andcond) :
{
  Object nested = null;
  List<Object> nestedCE = new ArrayList<Object>();
}
{
  LOOKAHEAD(<IDENTIFIER> <LBRACE>) CEType(nestedCE)
  {
    andcond.addAll(nestedCE);
    nestedCE.clear();
  }
|
  nested = expr()
  {
    TestCondition tc = new TestCondition();
    if (nested instanceof Function) {
      tc.setFunction((Function)nested);
    }
    andcond.addNestedConditionElement(tc);
  }
}

void temporalPattern(List<Object> list) :
{
  Token exp;
  // Object nested = null;
  List<Object> alpha = new ArrayList<Object>();
  TemporalCondition tmpc = new TemporalCondition();
  // List<Object> params = new ArrayList<Object>();
}
{
  // (temporal (declare ?binding (relative-time n) (interval-time n) (person (name "me") ) )
  temporalDeclaration(tmpc)
  <LBRACE> exp = <IDENTIFIER> ((templatePatterns(alpha))+)? <RBRACE>
  {
    tmpc.setTemplateName(exp.image);
    Iterator<Object> itr = alpha.iterator();
    while (itr.hasNext()) {
      tmpc.addConstraint((Constraint)itr.next());
    }
    list.add(tmpc);
    alpha.clear();
    exp = null;
  }
}

void temporalDeclaration(TemporalCondition tmpc) :
{
  Token exp2;
  Object etime;
  Object itime = null;
  List<Object> params = new ArrayList<Object>();
}
{
  <LBRACE> <DECLARE>
  exp2 = <BIND> 
  <LBRACE> <RELATIVETIME> etime = typeExpr() <RBRACE>
  (<LBRACE> <INTERVALTIME> itime = typeExpr() (<LBRACE> (valueParams(params))+ <RBRACE>)? <RBRACE>)?
  <RBRACE>
  {
    tmpc.setVariableName(exp2.image.substring(1));
    if (etime instanceof BigDecimal) {
      tmpc.setRelativeTime(((BigDecimal)etime).intValue());
    }
    if (itime != null && itime instanceof BigDecimal) {
      tmpc.setIntervalTime(((BigDecimal)itime).intValue());
      tmpc.addFunction(params);
    }
    exp2 = null;
  }
}

void templatePatterns(List<Object> list) :
{
  Token exp = null;
}
{
  // (template (slot value) )
  <LBRACE> exp = <IDENTIFIER> propertyType(list,exp) <RBRACE>
  {
    exp = null;
  }
}

void propertyType(List<Object> list, Token identifier) :
{
  Token id = null;
  Object body = null;
  Token body2 = null;
  boolean bval = false;
  LiteralConstraint vc;
  BoundConstraint bc;
  OrLiteralConstraint orc;
  AndLiteralConstraint andc;
  List<Object> andor = new java.util.ArrayList<Object>();
  MultiValue mv = null;
}
{
  // (slot ?binding&:(> ?binding 3) )
  LOOKAHEAD(<BIND2>) predicateFunc(list,identifier)
  {
    // do nothing
  }
|
  // multislot bind
  LOOKAHEAD(<BIND4>) body2 = <BIND4>
  {
    if (body2 != null) {
      bc = new BoundConstraint();
      bc.setName(identifier.image);
      bc.setValue(body2.image.substring(2));
      bc.setIsMultislot(true);
      list.add(bc);
    }
  }
|
  // (slot ?binding)
  LOOKAHEAD(<BIND><RBRACE>) body2 = <BIND>
  {
    if (body2 != null) {
      bc = new BoundConstraint();
      bc.setName(identifier.image);
      bc.setValue(body2.image.substring(1));
      list.add(bc);
    }
  }
|
  // (slot ~?binding)
  LOOKAHEAD(<TILDA><BIND><RBRACE>) <TILDA> body2 = <BIND>
  {
    if (body2 != null) {
      bc = new BoundConstraint();
      bc.setName(identifier.image);
      bc.setValue(body2.image.substring(1));
      bc.setNegated(true);
      list.add(bc);
    }
  }
|
  LOOKAHEAD((<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)<OR2>) body = typeExpr() 
    (<OR2> orType(andor))+
  {
    if (body != null) {
      orc = new OrLiteralConstraint();
      orc.setName(identifier.image);
      mv = new MultiValue(body);
      orc.addValue(mv);
      orc.addValues(andor);
      list.add(orc);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)<OR2>) <TILDA> body = typeExpr() 
    (<OR2> orType(andor))+
  {
    if (body != null) {
      orc = new OrLiteralConstraint();
      orc.setName(identifier.image);
      mv = new MultiValue(body);
      mv.setNegated(true);
      orc.addValue(mv);
      orc.addValues(andor);
      list.add(orc);
    }
  }
|
  // also handles intrafact comparison of bindings
  LOOKAHEAD((<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>|<BIND>)<AND2>) body = bindTypeExpr() 
    (<AND2> andType(andor))+
  {
    if (body != null) {
      if (body instanceof String && ((String)body).startsWith("?") ) {
        bc = new BoundConstraint();
        bc.setName(identifier.image);
        bc.setValue( ((String)body).substring(1) );
        bc.setIntraFactJoin(true);
        bc.addIntrFactJoin(andor);
        list.add(bc);
      } else {
        andc = new AndLiteralConstraint();
        andc.setName(identifier.image);
        mv = new MultiValue(body);
        andc.addValue(mv);
        andc.addValues(andor);
        list.add(andc);
      }
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)<AND2>) <TILDA> body = typeExpr() 
    (<AND2> andType(andor))+
  {
    if (body != null) {
      andc = new AndLiteralConstraint();
      andc.setName(identifier.image);
      mv = new MultiValue(body);
      mv.setNegated(true);
      andc.addValue(mv);
      andc.addValues(andor);
      list.add(andc);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)) <TILDA> body = typeExpr()
  {
    if (body != null) {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(body);
      vc.setNegated(true);
      list.add(vc);
    }
  }
|
  // (slot value)
  LOOKAHEAD(<IDENTIFIER>) id = <IDENTIFIER>
  {
    if (id != null) {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      if (id.image.equals("~nil")) {
        vc.setValue(null);
        vc.setNegated(true);
      } else {
        vc.setValue(id.image);
      }
      list.add(vc);
    }
  }
|
  LOOKAHEAD(<TILDA><IDENTIFIER>) <TILDA> id = <IDENTIFIER>
  {
    if (id != null) {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(id.image);
      vc.setNegated(true);
      list.add(vc);
    }
  }
|
  body = typeExpr()
  {
    if (body != null) {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(body);
      list.add(vc);
    }
  }
|
  bval = trueFalse()
  {
    vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(bval);
      list.add(vc);
  }
|
  <NIL>
  {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(null);
      list.add(vc);
  }
}

// either a bind or typeExpr
Object bindTypeExpr() :
{
  Token body = null;
  Object value = null;
}
{
  LOOKAHEAD(<BIND>) body = <BIND>
  {
    return body.image;
  }
|
  LOOKAHEAD( (<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>) ) value = typeExpr()
  {
    return value;
  }
}

// need to enhance to handling bindings
void andType(List<Object> list) :
{
  Token body = null;
  Object val = null;
  MultiValue mv = null;
  BoundConstraint bc;
}
{
  LOOKAHEAD(<IDENTIFIER>) body = <IDENTIFIER>
  {
    if (body != null) {
      mv = new MultiValue(body.image);
      list.add(mv);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)) <TILDA> val = typeExpr()
  {
    if (val != null) {
      mv = new MultiValue(val,true);
      list.add(mv);
    }
  }
|
  // a binding ?bind
  body = <BIND>
  {
    bc = new BoundConstraint();
    bc.setValue( body.image.substring(1) );
    list.add(bc);
  }
|
  // a negated binding ~?bind
  <TILDA> body = <BIND>
  {
    bc = new BoundConstraint();
    bc.setValue( body.image.substring(1) );
    bc.setNegated(true);
    list.add(bc);
  }
|
  val = typeExpr()
  {
    if (val != null) {
      mv = new MultiValue(val);
      list.add(mv);
    }
  }
}

void orType(List<Object> list) :
{
  Token body = null;
  Object val = null;
  MultiValue mv = null;
}
{
  LOOKAHEAD(<IDENTIFIER>) body = <IDENTIFIER>
  {
    if (body != null) {
      mv = new MultiValue(body.image);
      list.add(mv);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)) <TILDA> val = typeExpr()
  {
    if (val != null) {
      mv = new MultiValue(val,true);
      list.add(mv);
    }
  }
|
  val = typeExpr()
  {
    if (val != null) {
      mv = new MultiValue(val);
      list.add(mv);
    }
  }
}

void predicateFunc(List<Object> list, Token identifier) :
{
  Token varname = null;
  String func = null;
  List<Object> params = new ArrayList<Object>();
  // Token bind = null;
  // Token val = null;
}
{
  varname = <BIND2> <LBRACE> func = functionName() (valueParams(params))+ <RBRACE>
  {
    PredicateConstraint predc = new PredicateConstraint();
    predc.setName(identifier.image);
    predc.setVariableName(
      varname.image.substring(1,varname.image.length() -2));
    predc.setFunctionName(func);
    predc.addParameters(params);
    list.add(predc);
  }
}

String functionName() :
{
  Token fname = null;
}
{
  fname = <IDENTIFIER>
  {
    return fname.image;
  }
|
  (fname = <PLUS>|
   fname = <MINUS>|
   fname = <MULTIPLY>|
   fname = <DIVIDE>|
   fname = <GT1>|
   fname = <LT1>|
   fname = <EQ1>|
   fname = <EQ2>|
   fname = <LE1>|
   fname = <GE1>|
   fname = <AND1>|
   fname = <OR1>)
  {
    return fname.image;
  }
}

void arrow() :
{
  Token exp;
}
{
  exp = <ARROW>
  {
    exp = null;
  }
}

void leftarrow() :
{
  Token exp;
}
{
  exp = <LEFT_ARROW>
  {
    exp = null;
  }
}

void ruleActions(List<Object> list) :
{
}
{
  ((<LBRACE> ruleAction(list) <RBRACE>)+)?
  {
  }
}

void ruleAction(List<Object> list) :
{
  Object exp;
}
{
  exp = expr()
  {
    list.add(exp);
  }
}

Defquery queryBody() :
{
  Token exp = null;
  Token querycomment = null;
  Defquery query;
  List<Object> variables = new ArrayList<Object>();
  List<Object> conditions = new ArrayList<Object>();
}
{
  exp = <IDENTIFIER> (LOOKAHEAD(<STRING_LITERAL>)querycomment=<STRING_LITERAL>)?
  <LBRACE><DECLARE> <LBRACE><IDENTIFIER> (variables(variables))+ <RBRACE><RBRACE>
  ((conditionElement(conditions))+)?
  {
    query = new Defquery(exp.image);
    if (querycomment != null) {
      query.setComment(querycomment.image);
    }
    query.setQueryParameters(variables);
    Iterator<Object> itr = conditions.iterator();
    while (itr.hasNext()) {
      query.addCondition( (Condition)itr.next() );
    }
    
    variables.clear();
    conditions.clear();
    exp = null;
    return query;
  }
}

GraphQuery graphQueryBody() :
{
  Token exp = null;
  Token querycomment = null;
  GraphQuery query;
  List<Object> variables = new ArrayList<Object>();
  List<Object> conditions = new ArrayList<Object>();
}
{
  exp = <IDENTIFIER> (LOOKAHEAD(<STRING_LITERAL>)querycomment=<STRING_LITERAL>)?
  <LBRACE><DECLARE> <LBRACE><IDENTIFIER> (variables(variables))+ <RBRACE><RBRACE>
  ((conditionElement(conditions))+)?
  {
    query = new GraphQuery(exp.image);
    if (querycomment != null) {
      query.setComment(querycomment.image);
    }
    query.setQueryParameters(variables);
    Iterator<Object> itr = conditions.iterator();
    while (itr.hasNext()) {
      query.addCondition( (Condition)itr.next() );
    }
    
    variables.clear();
    conditions.clear();
    exp = null;
    return query;
  }
}

void variables(List<Object> list) :
{
  Token exp = null;
}
{
  exp = getBindType()
  {
    list.add(exp.image);
  }
}

Defcube cubeExpr() :
{
  Defcube cube;
  Token cubename;
  List<Object> conditions = new ArrayList<Object>();
  List<Object> dimensions = new ArrayList<Object>();
  List<Object> measures = new ArrayList<Object>();
}
{
  cubename = <IDENTIFIER>
  (LOOKAHEAD(<ASSIGN>) <ASSIGN> conditionElement(conditions))+
  (<LBRACE> cubeContents(dimensions, measures) <RBRACE>)+
  {
    cube = new Defcube(engine);
    cube.setName(cubename.image);
    cube.setDeftemplates(conditions);
    cube.setDimensions(dimensions);
    cube.setDefmeasures(measures);
    return cube;
  }
}

void cubeContents(List<Object> dimensions, List<Object> measures) :
{
  Token name;
  Token label;
  Token binding;
}
{
  LOOKAHEAD(<IDENTIFIER> <LBRACE>)
  label = <IDENTIFIER> 
  <LBRACE> name = <IDENTIFIER> binding = <BIND> <RBRACE>
  {
    Defmeasure m = new Defmeasure();
    m.setMeasureLabel(label.image);
    m.setMeasureName(name.image);
    m.setVariableName(binding.image.substring(1));
    measures.add(m);
  }
|
  <IDENTIFIER> name = <IDENTIFIER> binding = <BIND>
  {
    Defdimension d = new Defdimension(engine);
    d.setName(name.image);
    d.setVariableName(binding.image.substring(1));
    dimensions.add(d);
  }
}
